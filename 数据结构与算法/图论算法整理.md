# 图论算法整理

&ensp;&ensp;&ensp;&ensp;整理一些有关图论算法的东西，整理得比较随意，而且也是先整理一些，之后想到啥就补充一点改一点，所以在标题上写个杂。这篇笔记纯粹是整理着自己玩，所以 C++ 代码写得也很随意。

## 邻接表、拓扑排序
&ensp;&ensp;&ensp;&ensp;先来看一个有向图无环图。
![image-20200711221910952](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200711221910952.png#pic_center)
&ensp;&ensp;&ensp;&ensp;该有向图的全体边为：

<center>(A, B), (A, C), (A, F), (B, D), (B, E), (C, E), (D, C), (D, F), (F, E)

&ensp;&ensp;&ensp;&ensp;邻接表的结构也一目了然：

![image-20200711222037666](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200711222037666.png#pic_center)
&ensp;&ensp;&ensp;&ensp;写点代码，输入边，输出邻接表，写得可以说是很随意了：

```cpp
#ifndef GRAPH_GRAPH_H
#define GRAPH_GRAPH_H
#include <unordered_map>
#include <string>
#include <vector>
#include <iostream>
using namespace std;
class graph {
public:
    void insert(string, string);//输入
    void print();//输出邻接表
private:
    unordered_map<int,vector<int>> adjacencylist;//邻接表
    vector<int> Indegree;//入度数组
    unordered_map<string,int> node2index;//值到内部编号的哈希表
    unordered_map<int,string> index2node;//内部编号到值的哈希表
    int node_num = 0;//节点数
};
void graph::insert(string s1,string s2){
    if(node2index.find(s1) == node2index.end()){
        node2index[s1] = node_num;
        index2node[node_num] = s1;
        ++ node_num;
        Indegree.push_back(0);
    }
    if(node2index.find(s2) == node2index.end()){
        node2index[s2] = node_num;
        index2node[node_num] = s2;
        ++ node_num;
        Indegree.push_back(0);
    }
    adjacencylist[node2index[s1]].push_back(node2index[s2]);
    ++Indegree[node2index[s2]];
}

void graph::print() {
    for(int i = 0; i < node_num; ++i){
        cout << index2node[i]<<' ';
        for(int j = 0; j < adjacencylist[i].size(); ++j){
            cout<< index2node[adjacencylist[i][j]]<<' ';
        }
        cout<<endl;
    }
}

#endif //GRAPH_GRAPH_H
```

![image-20200711221818088](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200711221818088.png)
&ensp;&ensp;&ensp;&ensp;拓扑排序就是把有向无环图的节点排成一个序列，注意这个“有向”，点的顺序不能反了，如果有边(A,B)，那么在序列中A一定在B前面。
&ensp;&ensp;&ensp;&ensp;贴代码，重复的就不贴了

```cpp
#ifndef GRAPH_GRAPH_H
#define GRAPH_GRAPH_H
#include <unordered_map>
#include <string>
#include <vector>
#include <iostream>
using namespace std;
class graph {
public:
	...//同上
    vector<string> topsort();
private:
	...//同上
    int find_zero_indegree();//找入度为0的点，就是找入口呗
};
	...//同上
int graph::find_zero_indegree() {
    auto iter = find(indegree.begin(), indegree.end(), 0);
    if (iter == indegree.end())
        return -1;
    else {
        return iter - indegree.begin();
    }
}
vector<string> graph::topsort() {
    vector<string> topsort_result;
    for (int i = 0; i < node_num; ++i) {
        int innode = find_zero_indegree();
        if (innode == -1) {
            cout << "有环";//还没输出全部的点就找不到入度为0的点了，说明有环
            break;
        }
        indegree[innode] = -1;//删去这个点，直接入度为-1就行了
        topsort_result.push_back(index2node[innode]);
        for (auto outnode : adjacencylist[innode]) {
            --indegree[outnode];
        }
    }
    return topsort_result;
}
#endif //GRAPH_GRAPH_H
```
&ensp;&ensp;&ensp;&ensp;输入上面的例子看结果：

![image-20200711222152010](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200711222152010.png#pic_center)

&ensp;&ensp;&ensp;&ensp;有环的话会怎么样呢？当然是输出有环啦，不信看下面：

![image-20200711222231320](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200711222231320.png#pic_center)

（未完待续哈哈哈！）